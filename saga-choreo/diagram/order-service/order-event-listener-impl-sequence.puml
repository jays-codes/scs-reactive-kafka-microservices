@startuml OrderEventListenerImpl Sequence Diagram - Part 1

title OrderEventListenerImpl - Complete Order Flow (Part 1: Order Creation → Inventory Success)
skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true
skinparam maxMessageSize 200

' ==========================================
' PARTICIPANTS
' ==========================================

box "Client Layer" #LightYellow
    participant "REST Client" as Client
    participant "OrderController" as Controller
end box

box "Service Layer (Order Service)" #LightBlue
    participant "OrderServiceImpl" as OrderService
    participant "OrderFulfillmentServiceImpl" as FulfillmentService
    participant "PaymentComponentServiceImpl" as PymtComponentService
    participant "InventoryComponentServiceImpl" as InvComponentService
end box

box "Data Layer (Order Service)" #LightCoral
    participant "PurchaseOrderRepository" as PORepo
    participant "OrderPaymentRepository" as PymtRepo
    participant "OrderInventoryRepository" as InvRepo
end box

box "Messaging Layer (Order Service)" #LightGreen
    participant "OrderEventListenerImpl" as EventListener
    participant "Sinks.Many<OrderEvent>" as Sink
    participant "OrderEventMapper" as OrderMapper
    participant "PaymentEventProcessorImpl" as PymtProcessor
    participant "PaymentEventMapper" as PymtMapper
    participant "InventoryEventProcessorImpl" as InvProcessor
    participant "InventoryEventMapper" as InvMapper
end box

box "Kafka Infrastructure" #LightGray
    participant "Kafka Topic\n(order-events)" as OrderTopic
    participant "Kafka Topic\n(payment-events)" as PaymentTopic
    participant "Kafka Topic\n(inventory-events)" as InvTopic
    participant "Spring Cloud\nStream" as SCS
end box

box "External Services" #LightCyan
    participant "Payment Service" as PaymentSvc
    participant "Inventory Service" as InventorySvc
end box

' ==========================================
' SCENARIO 1: ORDER PLACEMENT → INVENTORY SUCCESS → ORDER COMPLETION
' ==========================================

== Scenario 1: Order Placement → Component Success → Order Completion ==

Client -> Controller : POST /orders\nOrderCreateRequest(customerId=1, productId=100, qty=2, unitPrice=5)
activate Controller

Controller -> OrderService : placeOrder(OrderCreateRequest)
activate OrderService

note over OrderService
  **Step 1: Entity Creation**
  EntityDTOMapper.toPurchaseOrder(request)
  • Calculate amount: qty * unitPrice = 10
  • Set status: PENDING
end note

OrderService -> OrderService : EntityDTOMapper.toPurchaseOrder(request)

OrderService -> PORepo : save(PurchaseOrder)
activate PORepo

note right of PORepo
  INSERT INTO purchase_order
  VALUES (
    order_id = abc-123 (auto-generated),
    customer_id = 1,
    product_id = 100,
    quantity = 2,
    unit_price = 5,
    amount = 10,
    status = 'PENDING',
    delivery_date = null
  )
end note

PORepo --> OrderService : Mono<PurchaseOrder>\n(orderId=abc-123, status=PENDING)
deactivate PORepo

OrderService -> OrderService : map(EntityDTOMapper::toPurchaseOrderDTO)

note over OrderService
  **Step 2: DTO Transformation**
  Entity → PurchaseOrderDTO (immutable)
end note

OrderService -> EventListener : doOnNext(ordEvtLstnr::emitOrderCreated(PurchaseOrderDTO))
activate EventListener

note over EventListener
  **OrderEventListenerImpl**
  Implements:
  • OrderEventListener (domain interface)
  • EventPublisher<OrderEvent> (messaging interface)
end note

EventListener -> OrderMapper : toOrderCreatedEvent(PurchaseOrderDTO)
activate OrderMapper

note right of OrderMapper
  Create OrderEvent.OrderCreated:
  • orderId: abc-123
  • customerId: 1
  • productId: 100
  • quantity: 2
  • unitPrice: 5
  • totalAmount: 10
  • createdAt: Instant.now()
end note

OrderMapper --> EventListener : OrderEvent.OrderCreated
deactivate OrderMapper

EventListener -> Sink : sink.emitNext(OrderEvent.OrderCreated,\nEmitFailureHandler.busyLooping(1s))
activate Sink

note over Sink
  **Sinks.Many<OrderEvent>**
  • Multicast sink
  • Backpressure: busyLooping
  • Retry: 1 second
end note

Sink --> EventListener : EmitResult.OK
deactivate Sink

EventListener --> OrderService : void (side effect completed)
deactivate EventListener

OrderService --> Controller : Mono<PurchaseOrderDTO>\n(orderId=abc-123, status=PENDING)
deactivate OrderService

Controller --> Client : HTTP 201 Created\nPurchaseOrderDTO(orderId=abc-123, status=PENDING)
deactivate Controller

note over Client
  **Client receives immediate response**
  Order created but not yet completed
  (async processing continues below)
end note

' ==========================================
' KAFKA PUBLISHING FLOW
' ==========================================

== Kafka Publishing (Async) ==

Sink -> SCS : Flux<OrderEvent> (from sink.asFlux())
activate SCS

note over SCS
  **Spring Cloud Stream**
  Function: orderEventProducer
  Binding: orderEventProducer-out-0
  Destination: order-events
end note

SCS -> OrderTopic : Message<OrderEvent.OrderCreated>\n(key=abc-123, payload=OrderCreated)
deactivate SCS

note over OrderTopic
  **Saga Choreography Begins**
  Multiple services consume in parallel
end note

' ==========================================
' PARALLEL PROCESSING (PAYMENT & INVENTORY)
' ==========================================

== Parallel Processing (Payment & Inventory Services) ==

OrderTopic -> PaymentSvc : OrderEvent.OrderCreated
activate PaymentSvc
note over PaymentSvc
  **Payment Service Processing**
  1. Validate customer
  2. Check balance
  3. Deduct payment
  4. Emit PaymentDeducted event
end note
PaymentSvc --> PaymentTopic : PaymentEvent.PaymentDeducted\n(orderId=abc-123, paymentId=pmt-789)
deactivate PaymentSvc

OrderTopic -> InventorySvc : OrderEvent.OrderCreated
activate InventorySvc

note over InventorySvc
  **Inventory Service Processing**
  1. Validate stock availability
  2. Reserve inventory
  3. Emit InventoryDeducted event
end note

InventorySvc --> InvTopic : InventoryEvent.InventoryDeducted\n(orderId=abc-123, inventoryId=inv-456, productId=100, qty=2)
deactivate InventorySvc

' ==========================================
' INVENTORY EVENT CONSUMPTION (ORDER SERVICE)
' ==========================================

== Inventory Event Consumption (Order Service) ==

InvTopic -> SCS : Message<InventoryEvent.InventoryDeducted>
activate SCS

note over SCS
  **Spring Cloud Stream**
  Function: inventoryProcessor
  Binding: inventoryProcessor-in-0
  Destination: inventory-events
end note

SCS -> InvProcessor : Flux<Message<InventoryEvent>>
activate InvProcessor

note over InvProcessor
  **InventoryEventProcessorImpl**
  Pattern matching switch:
  case InventoryDeducted e -> handle(e)
end note

InvProcessor -> InvMapper : toOrderInventoryDTO(InventoryDeducted)
activate InvMapper
InvMapper --> InvProcessor : OrderInventoryDTO\n(orderId=abc-123, inventoryId=inv-456, status=DEDUCTED)
deactivate InvMapper

InvProcessor -> InvComponentService : statusListener.onSuccess(OrderInventoryDTO)
activate InvComponentService

note over InvComponentService
  **Step 1: Component Tracking**
  Materialized view update
end note

InvComponentService -> InvRepo : findByOrderId(abc-123)
activate InvRepo
InvRepo --> InvComponentService : Mono.empty() (first time)
deactivate InvRepo

InvComponentService -> InvComponentService : switchIfEmpty(Mono.defer(() -> add(dto, true)))

note over InvComponentService
  add() method:
  1. EntityDTOMapper.toOrderInventory(dto)
  2. entity.setSuccess(true)
  3. invRepo.save(entity)
end note

InvComponentService -> InvRepo : save(OrderInventory)\n(orderId=abc-123, inventoryId=inv-456, success=true, status=DEDUCTED)
activate InvRepo

note right of InvRepo
  INSERT INTO order_inventory
  VALUES (
    order_id = abc-123,
    inventory_id = inv-456,
    success = true,
    status = 'DEDUCTED',
    message = null
  )
end note

InvRepo --> InvComponentService : Mono<OrderInventory>
deactivate InvRepo

InvComponentService -> InvComponentService : .then() → Mono<Void>

InvComponentService --> InvProcessor : Mono<Void> (completion signal)
deactivate InvComponentService

' ==========================================
' PAYMENT EVENT CONSUMPTION (ORDER SERVICE)
' ==========================================

== Payment Event Consumption (Order Service) ==

note over PaymentTopic
  **Parallel to Inventory Processing**
  Payment service also emitted PaymentDeducted
end note

PaymentTopic -> SCS : Message<PaymentEvent.PaymentDeducted>
activate SCS

note over SCS
  **Spring Cloud Stream**
  Function: paymentProcessor
  Binding: paymentProcessor-in-0
  Destination: payment-events
end note

SCS -> PymtProcessor : Flux<Message<PaymentEvent>>
activate PymtProcessor

note over PymtProcessor
  **PaymentEventProcessorImpl**
  Pattern matching switch:
  case PaymentDeducted e -> handle(e)
end note

PymtProcessor -> PymtMapper : toOrderPaymentDTO(PaymentDeducted)
activate PymtMapper
PymtMapper --> PymtProcessor : OrderPaymentDTO\n(orderId=abc-123, paymentId=pmt-789, status=DEDUCTED)
deactivate PymtMapper

PymtProcessor -> PymtComponentService : statusListener.onSuccess(OrderPaymentDTO)
activate PymtComponentService

note over PymtComponentService
  **Step 1: Component Tracking**
  Materialized view update
end note

PymtComponentService -> PymtRepo : findByOrderId(abc-123)
activate PymtRepo
PymtRepo --> PymtComponentService : Mono.empty() (first time)
deactivate PymtRepo

PymtComponentService -> PymtComponentService : switchIfEmpty(Mono.defer(() -> add(dto, true)))

note over PymtComponentService
  add() method:
  1. EntityDTOMapper.toOrderPayment(dto)
  2. entity.setSuccess(true)
  3. pymtRepo.save(entity)
end note

PymtComponentService -> PymtRepo : save(OrderPayment)\n(orderId=abc-123, paymentId=pmt-789, success=true, status=DEDUCTED)
activate PymtRepo

note right of PymtRepo
  INSERT INTO order_payment
  VALUES (
    order_id = abc-123,
    payment_id = pmt-789,
    success = true,
    status = 'DEDUCTED',
    message = null
  )
end note

PymtRepo --> PymtComponentService : Mono<OrderPayment>
deactivate PymtRepo

PymtComponentService -> PymtComponentService : .then() → Mono<Void>

PymtComponentService --> PymtProcessor : Mono<Void> (completion signal)
deactivate PymtComponentService

PymtProcessor -> FulfillmentService : fulfillmentService.completeOrder(abc-123)
activate FulfillmentService

note over FulfillmentService #FFAAAA
  **Race Condition Check**
  
  Payment arrived first, but inventory not yet processed
  → completeOrder() returns Mono.empty()
  → No OrderCompleted event emitted yet
end note

FulfillmentService -> PORepo : getWhenOrderComponentsAreSuccess(abc-123)
activate PORepo

note right of PORepo
  **Custom SQL Query:**
  Checks:
  • po.status = 'PENDING' ✓
  • op.success = true ✓ (just inserted)
  • oi.success = true ✗ (not yet inserted)
  
  Result: Mono.empty()
end note

PORepo --> FulfillmentService : Mono.empty() (conditions not met)
deactivate PORepo

FulfillmentService --> PymtProcessor : Mono.empty()
deactivate FulfillmentService

PymtProcessor --> SCS : Mono.empty() (no event)
deactivate PymtProcessor

deactivate SCS

note over PaymentTopic
  **No OrderCompleted event yet**
  Waiting for inventory to complete
end note

' ==========================================
' ORDER COMPLETION (AFTER BOTH COMPONENTS SUCCESS)
' ==========================================

== Order Completion (Inventory Arrives Last) ==

note over InvTopic
  **Back to Inventory Processing**
  Inventory completes after payment
end note

InvProcessor -> FulfillmentService : fulfillmentService.completeOrder(abc-123)
activate FulfillmentService

note over FulfillmentService
  **Step 2: Order Fulfillment Decision**
  Database-level aggregation
end note

FulfillmentService -> PORepo : getWhenOrderComponentsAreSuccess(abc-123)
activate PORepo

note right of PORepo
  **Custom SQL Query:**
  SELECT po.*
  FROM purchase_order po
  WHERE po.order_id = 'abc-123'
    AND po.status = 'PENDING'
    AND EXISTS (
      SELECT 1
      FROM order_payment op,
           order_inventory oi
      WHERE op.order_id = po.order_id
        AND oi.order_id = po.order_id
        AND op.success = true
        AND oi.success = true
    )
end note

PORepo --> FulfillmentService : Mono<PurchaseOrder>\n(orderId=abc-123, status=PENDING)
deactivate PORepo

note over FulfillmentService #AAFFAA
  **All Conditions Met:**
  ✓ Order is PENDING
  ✓ Payment succeeded (op.success=true)
  ✓ Inventory succeeded (oi.success=true)
  
  → Proceed with order completion
end note

FulfillmentService -> FulfillmentService : doOnNext(entity.setStatus(COMPLETED))

FulfillmentService -> PORepo : save(PurchaseOrder)\n(status: PENDING → COMPLETED)
activate PORepo

note right of PORepo
  UPDATE purchase_order
  SET status = 'COMPLETED'
  WHERE order_id = 'abc-123'
end note

PORepo --> FulfillmentService : Mono<PurchaseOrder>
deactivate PORepo

FulfillmentService -> FulfillmentService : map(EntityDTOMapper::toPurchaseOrderDTO)

FulfillmentService --> InvProcessor : Mono<PurchaseOrderDTO>\n(orderId=abc-123, status=COMPLETED)
deactivate FulfillmentService

InvProcessor -> OrderMapper : toOrderCompletedEvent(PurchaseOrderDTO)
activate OrderMapper

note right of OrderMapper
  Create OrderEvent.OrderCompleted:
  • orderId: abc-123
  • createdAt: Instant.now()
end note

OrderMapper --> InvProcessor : OrderEvent.OrderCompleted\n(orderId=abc-123)
deactivate OrderMapper

InvProcessor --> SCS : Mono<OrderEvent.OrderCompleted>
deactivate InvProcessor

SCS -> OrderTopic : Message<OrderEvent.OrderCompleted>\n(key=abc-123)
deactivate SCS

note over OrderTopic
  **Downstream Services React:**
  • Payment Service: No action (terminal event)
  • Inventory Service: No action (terminal event)
  • Shipping Service: scheduleShipment()
end note

' ==========================================
' NOTES
' ==========================================

note over Client, InventorySvc
  **Key Concepts Demonstrated (Part 1)**
  
  1. **Saga Initiation**: OrderServiceImpl.placeOrder() → emitOrderCreated()
  2. **Event Publishing**: OrderEventListenerImpl uses Sinks.Many for Kafka publishing
  3. **Parallel Processing**: Payment & Inventory services process OrderCreated simultaneously
  4. **Component Tracking**: order_payment & order_inventory tables maintain materialized views
  5. **Race Condition Handling**: Payment arrives first → completeOrder() returns empty
  6. **Database-Level Aggregation**: SQL EXISTS checks ALL component success atomically
  7. **Order Completion**: Inventory arrives last → ALL conditions met → status=COMPLETED
  8. **Event Emission**: OrderCompleted event published for downstream services
  
  **Flow Summary:**
  Client → OrderService → EventListener → order-events → 
  Payment/Inventory Services (parallel) → 
  payment-events/inventory-events → 
  PaymentEventProcessorImpl/InventoryEventProcessorImpl → 
  PaymentComponentService/InventoryComponentService (materialized views) → 
  FulfillmentService.completeOrder() (race: payment first=empty, inventory last=success) → 
  OrderCompleted Event → order-events
  
  **Database Tables Updated:**
  • purchase_order: status PENDING → COMPLETED
  • order_payment: INSERT (success=true, status=DEDUCTED)
  • order_inventory: INSERT (success=true, status=DEDUCTED)
  
  **See Part 2 for**: Inventory Failure → Order Cancellation scenario
end note

@enduml
